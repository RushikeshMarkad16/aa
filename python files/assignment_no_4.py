# -*- coding: utf-8 -*-
"""Assignment_No_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AT5zk6oQEaUK8SF2QOsLcerVSi0UB94O

# Assignment 4: Data Analytics 1 
    
    Create a Linear Regression Model using Python/R to predict home prices using Boston Housing Dataset (https://www.kaggle.com/c/boston-housing). The Boston Housing dataset contains information about various houses in Boston through different parameters. There are 506 samples and 14 feature variables in this dataset.
    The objective is to predict the value of prices of the house using the given features.

The Boston Housing Dataset is a derived from information collected by the U.S. Census Service concerning housing in the area of Boston MA. The following describes the dataset columns:

CRIM - per capita crime rate by town                                                                                             
ZN - proportion of residential land zoned for lots over 25,000 sq.ft                                                             
INDUS - proportion of non-retail business acres per town.                                                                       
CHAS - Charles River dummy variable (1 if tract bounds river; 0 otherwise)                                                    
NOX - nitric oxides concentration (parts per 10 million)                                                                     
RM - average number of rooms per dwelling                                                                                
AGE - proportion of owner-occupied units built prior to 1940                                                            
DIS - weighted distances to five Boston employment centres                                                                
RAD - index of accessibility to radial highways                                                                             
TAX - full-value property-tax rate per 10,000 dollars                                                                           
PTRATIO - pupil-teacher ratio by town                                                                                         
B - 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town                                                           
LSTAT - % lower status of the population                                                                                     
MEDV - Median value of owner-occupied homes in $1000's                                                                          
Label = MEDV
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt  
import seaborn as sns
from sklearn.metrics import mean_squared_error,mean_absolute_error

pd.read_csv("housing.csv")

column_names = ['CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', 'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT','MEDV']
df = pd.read_csv('housing.csv', header=None,delimiter=r"\s+", names=column_names)

df.head()

df.describe()

df.isnull()

df.isnull().sum()

df.info()

df.shape

"""# Correlation matrix and heatmap"""

corr_matrix=round(df.corr(),2)
print(corr_matrix)

plt.figure(figsize=(20,15))
sns.heatmap(corr_matrix,annot=True)

"""# Scatter graph of each feature against MEDV"""

cols=['CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', 'DIS', 'RAD', 'TAX', 'PTRATIO', 'B']
x = df[cols]
y = df['MEDV']
fig, axs = plt.subplots(ncols=4, nrows=3, figsize=[20, 10])
axs = axs.flatten()
for i, k in enumerate(cols):
    sns.regplot(x=x[k], y=y, ax=axs[i])

y = df['MEDV']
x = df.loc[:,df.columns!='MEDV']

print(np.shape(y))
print(np.shape(x))

x.head()

y.head()

"""# Prediction for 20% test size"""

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.2)

x_train.shape

x_test.shape

x_train[0:5]

x_test[0:5]

"""# Scaled the x dataset"""

from sklearn import preprocessing
ss = preprocessing.StandardScaler()
x_train =  ss.fit_transform(x_train)
x_test = ss.transform(x_test)

x_train[0:5]

x_test[0:5]

y_train = np.asarray(y_train)
y_test = np.asarray(y_test)

print(x_train.shape)
print(x_test.shape)
print(y_train.shape)
print(y_test.shape)

"""# Fitting the model"""

from sklearn.linear_model import LinearRegression
reg = LinearRegression().fit(x_train, y_train)
scores = reg.score(x_test, y_test)
scores

y_pred = reg.predict(x_test)
df_preds = pd.DataFrame({'Actual: ': y_test, 'Predicted: ': y_pred})
df_preds.head(10)

reg.coef_

reg.intercept_

from sklearn import metrics
from sklearn.metrics import mean_squared_error,mean_absolute_error
print("For test data")
print("MSE:", mean_squared_error(y_test, y_pred))
print("MAE:", mean_absolute_error(y_test, y_pred))
print("RMSE:", np.sqrt(mean_squared_error(y_test, y_pred)))
print('accuracy:',metrics.r2_score(y_test, y_pred))

y_pred_train = reg.predict(x_train)

from sklearn import metrics
from sklearn.metrics import mean_squared_error,mean_absolute_error
print("For train data")
print("MSE:", mean_squared_error(y_train, y_pred_train))
print("MAE:", mean_absolute_error(y_train, y_pred_train))
print("RMSE:", np.sqrt(mean_squared_error(y_train, y_pred_train)))
print('accuracy:',metrics.r2_score(y_train, y_pred_train))

"""# Prediction for 25% test size"""

x_train1, x_test1, y_train1, y_test1 = train_test_split(x,y,test_size=0.25)

x_train1 =  ss.fit_transform(x_train1)
x_test1 = ss.transform(x_test1)

y_train1 = np.asarray(y_train1)
y_test1 = np.asarray(y_test1)

reg1 = LinearRegression().fit(x_train1, y_train1)
scores1 = reg1.score(x_test1, y_test1)
print(scores1)

y_pred1 = reg1.predict(x_test1)
df_preds1 = pd.DataFrame({'Actual: ': y_test1, 'Predicted: ': y_pred1})
df_preds1.head(10)

reg1.coef_

reg1.intercept_

print("For test data")
print("MSE:", mean_squared_error(y_test1, y_pred1))
print("MAE:", mean_absolute_error(y_test1, y_pred1))
print("RMSE:", np.sqrt(mean_squared_error(y_test1, y_pred1)))
print('Accuracy:',metrics.r2_score(y_test1, y_pred1))

y_pred_train1 = reg1.predict(x_train1)
print("For train data")
print("MSE:", mean_squared_error(y_train1, y_pred_train1))
print("MAE:", mean_absolute_error(y_train1, y_pred_train1))
print("RMSE:", np.sqrt(mean_squared_error(y_train1, y_pred_train1)))
print('Accuracy:',metrics.r2_score(y_train1, y_pred_train1))

